{% extends 'templates/_base.html' %}

{% block title %}Řetězce{% endblock %}

{% block content %}

            <div class="slides row stuff">
                <section class="col-lg-12">
                    <section>
                        <h1>Řetězce</h1>
                        <aside class="notes">
                            Teď se podíváme na zoubek řetězcům (angl. <em>strings</em>).
                            Už víme, jak je zapisovat:
                        </aside>
<pre>
'tohle je řetězec'
"tohle taky"
</pre>
                        <aside class="notes">
                            Někdy ale potřebujeme řetězce,
                            které obsahují více řádků.
                            Pythoní řetězce ale můžeme normálně napsat
                            jen na jeden řádek.
                            Jinak by koncová uvozovka mohla být kdekoli,
                            a špatně by se hledala, kdybychom na ni zapomněli.
                        </aside>
                        <aside class="notes">
                            Můžeme ale do řetězce znak pro
                            nový řádek vložit pomocí speciálního
                            zápisu <code>\n</code>:
                        </aside>
<pre class="fragment">
print('Haló haló!\nCo se stalo?')
</pre>
                        <aside class="notes">
                            Obecně nám zpětné lomítko umožňuje zapsat znaky,
                            které by se špatně zadávaly.
                            Třeba uvozovka se dá zapsat jako <code>\"</code>,
                            a „apostrof“ jako <code>\'</code>.
                            To se dá použít, když potřebujeme mít v jednom
                            řetězci uvozovku i apostrof:
                        </aside>
<pre class="fragment">
print("Vtom vnuk křik': \"Hleď!\"")
print('"Jen ho nech," řek\' děd. "Kdo zná líp kraj?"')
</pre>
                        <aside class="notes">
                            Zpětným lomítkem se dají přidávat i
                            exotické znaky, které nemáme na klávesnici.
                            Píšeme je jako \N a jméno znaku
                            v kudrnatých závorkách. Třeba:
                        </aside>
<pre class="fragment">
print('--\N{BLACK STAR}--')
print('--\N{SNOWMAN}--')
print('--\N{KATAKANA LETTER KO}--')
</pre>
                        <aside class="notes">
                            Tahle vychytávka má jeden, někdy nepříjemný,
                            důsledek: pokud chceme použít zpětné lomítko
                            (třeba ve jménech souborů na Windows),
                            musíme ho ve zdrojovém kódu zdvojit.
                            Sekvence <code>\\</code> znamená „jedno zpětné
                            lomítko“.
                        </aside>
<pre class="fragment">
print('C:\\PyLadies\\Nový adresář')
</pre>
                    </section>
                </section>
                <section class="col-lg-12">
                    <section>
                        <aside class="notes">
                            Ale zpátky k řetězcům na více řádků.
                            Kromě <code>\n</code> je i druhý způsob, jak takový
                            řetězec zadat: ohraničit ho <em>třemi</em>
                            uvozovkami (jednoduchými nebo dvojitými)
                            na každé straně:
                        </aside>
                        <aside class="notes">
                            Na rozdíl od „normálních“ řetězců,
                            s tímhle zápisem může mít řetězec více řádků:
                        </aside>
<pre>
basen = '''Haló haló!
Co se stalo?
Prase kozu potrkalo!'''
</pre>
                        <aside class="notes">
                            Takové dlouhé texty nachází uplatnění
                            třeba v dokumentačních řetězcích.
                        </aside>
<pre class="fragment">
def vynasob(a, b):
    """Vynásobí argumenty, a vrátí výsledek.

    Oba argumenty by měly být čísla.
    """
    return a * b
</pre>
                        <aside class="notes">
                            Jen pozor na to, že pokud je tenhle řetězec
                            v odsazeném kódu, každý jeho řádek bude začínat
                            několika mezerami.
                        </aside>
                        <aside class="notes">
                            Tolik k zápisu řetězců.
                        </aside>
                    </section>
                </section>
                <section class="col-lg-12">
                    <section>
                        <h1>Výběr znaků</h1>
                        <aside class="notes">
                            Řetězce už umíme spojovat dohromady:
                        </aside>
<pre>
spojeny_retezec = 'a' + 'b'
dlouhy_retezec = 'ó' * 100
</pre>
                        <aside class="notes">
                            Teď se podíváme na to, jak z dlouhého
                            řetězce dostat jednotlivé znaky.
                            Dělá se to operací <em>vybrání prvku</em>
                            (angl. <em>subscripting</em>),
                            která se píše podobně jako volání funkce,
                            jen s hranatými závorkami:
                        </aside>
<pre class="fragment">
pate_pismeno = 'čokoláda'[5]

print(pate_pismeno)
</pre>
                        <aside class="notes">
                            Funguje to? Dostala jsi opravdu páté písmeno?
                        </aside>
                    <section>
                    </section>
<details class="solution notes">
                        <aside class="notes">
                            Nedostala – dostala jsi <em>šesté</em> písmeno.
                        </aside>
</details>
                        <aside class="notes">
                            Jak sis možná už všimla, programátoři
                            počítají od nuly.
                            „První“ domácí úloha měla vždy číslo nula,
                            druhá číslo jedna, a tak dál.
                        </aside>
                        <aside class="notes">
                            Stejně je to i s písmeny v řetězcích:
                            první písmeno má číslo nula,
                            druhé jedna, ... a osmé písmeno má číslo sedm.
                        </aside>
                        <aside class="notes">
                            Proč je tomu tak?
                            K úplnému pochopení důvodů by ses potřebovala
                            naučit něco o ukazatelích a polích,
                            což nebude hned, takže pro teď nám bude
                            stačit vědět,
                            že programátoři jsou prostě divní.
                        </aside>
                        <aside class="notes">
                            A nebo, že mají rádi divná čísla, jako nulu.
                        </aside>
                    </section>
                    <section>
<pre>
   [0] [1] [2] [3] [4] [5] [6] [7]

  ╭───┬───┬───┬───┬───┬───┬───┬───╮
  │ Č │ o │ k │ o │ l │ á │ d │ a │
  ╰───┴───┴───┴───┴───┴───┴───┴───╯
</pre>
                    </section>
                    <section>
                        <aside class="notes">
                            A když už jsme u divných čísel,
                            co se asi stane, když budu chtít vybírat písmena
                            pomocí záporných čísel?
                        </aside>
<details class="solution">
<pre>
print('Čokoláda'[-1])  <span class="comment"># → a</span>
print('Čokoláda'[-2])  <span class="comment"># → d</span>
print('Čokoláda'[-3])  <span class="comment"># → á</span>
print('Čokoláda'[-4])  <span class="comment"># → l</span>
</pre>
</details>
                        <aside class="notes">
                            Záporná čísla vybírají písmenka od konce.
                        </aside>
<pre>
   [0] [1] [2] [3] [4] [5] [6] [7]
   [-8][-7][-6][-5][-4][-3][-2][-1]
  ╭───┬───┬───┬───┬───┬───┬───┬───╮
  │ Č │ o │ k │ o │ l │ á │ d │ a │
  ╰───┴───┴───┴───┴───┴───┴───┴───╯
</pre>
                    </section>
                    <section>
                        <aside class="notes">
                            Řetězce umí i jiné triky.
                            Třeba můžeme zjistit, jak je řetězec dlouhý,
                            nebo jestli v sobě obsahuje daný menší řetězec.
                        </aside>
                        <aside class="notes">
                            <table class="table">
                                <tr>
                                    <th>Zápis</th>
                                    <th>Popis</th>
                                    <th>Příklad</th>
                                </tr>
                                <tr>
                                    <td><code>len(r)</code></td>
                                    <td>Délka řetězce</td>
                                    <td><code>len('čokoláda') == 8</code></td>
                                </tr>
                                <tr>
                                    <td><code>x&nbsp;in&nbsp;r</code></td>
                                    <td>True pokud je řetězec <code>x</code> obsažen v <code>r</code></td>
                                    <td><code>'kol' in 'čokoláda' == True</code></td>
                                </tr>
                                <tr>
                                    <td><code>x&nbsp;not&nbsp;in&nbsp;r</code></td>
                                    <td>Opak <code>x in r</code></td>
                                    <td><code>'dub' not in 'čokoláda' == True</code></td>
                                </tr>
                            </table>
                        </aside>
                        <aside class="notes">
                            Řetězce vždy berou v potaz velikost písmen,
                            takže např. <code>'ČOKO' in 'čokoláda' == False</code>.
                            Kdybychom chtěli porovnávat bez ohledu na velikost písmen,
                            musíme oba řetězce převést na malá písmena,
                            a pak je porovnat.
                        </aside>
                        <aside class="notes">
                            A jak se převádí na malá písmena?
                            K tomu budeme potřebovat další novou
                            vlastnost Pythonu: metody.
                        </aside>
                    </section>
                </section>
                <section class="col-lg-12">
                    <section>
                        <h2>Metody</h2>
                        <aside class="notes">
                            Metoda (angl. <em>method</em>) je jako funkce,
                            jen je svázaná s nějakým <em>objektem</em>
                            (hodnotou).
                            Volá se tak, že se za objekt napíše tečka,
                            za ní jméno metody,
                            a za to celé se, jako u funkcí, připojí závorky
                            (s případnými argumenty).
                        </aside>
                        <aside class="notes">
                            Metody <code>upper()</code> a <code>lower()</code>
                            převádí text na velká, respektive malá písmena.
                        </aside>
<pre>
retezec = 'Ahoj'
print(retezec.upper())
print(retezec.lower())
print(retezec)
</pre>
                        <aside class="notes">
                            Všimni si, že původní řetězec se nemění;
                            metoda vrátí řetězec nový.
                        </aside>
                    </section>
                    <section>
                        <aside class="notes">
                            Zkus si, pro cvik, napsat tento program:
                        </aside>
                        <h3>Iniciály</h3>
                        <div>
                            Program se zeptá na jméno, pak na příjmení,
                            a pak vypíše iniciály – první písmena zadaných jmen.<br>
                            Iniciály jsou vždycky velkými písmeny
                            (i kdyby byl uživatel líný mačkat Shift).
                        </div>
<details class="solution">
<pre>
jmeno = input('Zadej jméno: ')
prijmeni = input('Zadej příjmení ')
inicialy = jmeno[0] + prijmeni[0]
print('Iniciály:', inicialy.upper())
</pre>
</details>
                    </section>
                    <section>
                        <aside class="notes">
                            Nebo to jde zapsat i takto –
                            metoda se dá volat na výsledku jakéhokoli výrazu:
                        </aside>
<pre>
jmeno = input('Zadej jméno: ')
prijmeni = input('Zadej příjmení ')
print('Iniciály:', (jmeno[0] + prijmeni[0]).upper())
</pre>
                        <aside class="notes">
                            Tady je pár metod řetězců,
                            které můžou být užitečné:
                        </aside>
                        <aside class="notes">
                            <table class="table">
                                <tr>
                                    <th>Metoda</th>
                                    <th>Popis</th>
                                    <th>Příklad</th>
                                </tr>
                                <tr>
                                    <td><code>r.upper()</code></td>
                                    <td>převod na velká písmena</td>
                                    <td><code>'Abc'.upper() == 'ABC'</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.lower()</code></td>
                                    <td>převod na malá písmena</td>
                                    <td><code>'Abc'.upper() == 'abc'</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.count(s)</code></td>
                                    <td>počet výskytů <code>s</code> v řetězci <code>r</code></td>
                                    <td><code>'popokatepetl'.count('e') == 2</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.index(s)</code></td>
                                    <td>pozice prvního výskytu <code>s</code> v řetězci <code>r</code></td>
                                    <td><code>'popokatepetl'.index('o') == 1</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.index(s, n)</code></td>
                                    <td>jako <code>r.index(s)</code>, ale hledá od pozice <code>n</code></td>
                                    <td><code>'popokatepetl'.index('o', 2) == 3</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.lstrip()</code></td>
                                    <td>odstraní mezery ze začátku řetězce</td>
                                    <td><code>'  bum  '.lstrip() == 'bum  '</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.rstrip()</code></td>
                                    <td>odstraní mezery z konce řetězce</td>
                                    <td><code>'  bum  '.lstrip() == '  bum'</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.strip()</code></td>
                                    <td>odstraní mezery ze začátku i konce</td>
                                    <td><code>'  bum  '.lstrip() == 'bum'</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.replace(a,&nbsp;b)</code></td>
                                    <td>nahradí <code>a</code> za <code>b</code></td>
                                    <td><code>'4.03'.replace('.', ',') == '4,03'</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.startswith(s)</code></td>
                                    <td>True, pokud <code>r</code> začíná řetězcem <code>s</code></td>
                                    <td><code>'popokatepetl'.startswith('pop') == True</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.endswith(s)</code></td>
                                    <td>True, pokud <code>r</code> končí řetězcem <code>s</code></td>
                                    <td><code>'popokatepetl'.endswith('petl') == True</code></td>
                                </tr>
                                <tr>
                                    <td><code>r.format(...)</code></td>
                                    <td>formátování</th>
                                    <td>viz níže</td>
                                </tr>
                            </table>
                        </aside>
                        <aside class="notes">
                            Všechny další jsou popsány v
                            <a href="https://docs.python.org/2/library/stdtypes.html#string-methods">
                                dokumentaci Pythonu
                            </a> (anglicky; plné věcí, které ještě neznáme).
                        </aside>
                        <aside class="notes">
                            Všimni si, že <code>len</code> není metoda,
                            ale funkce;
                            píše se <code>len(r)</code>,
                            ne <code>r.len()</code>.
                            Proč tomu tak je, to za nějakou dobu uvidíme.
                        </aside>
                    </section>
                </section>
                <section class="col-lg-12">
                    <section>
                        <h2>Formátování</h2>
                        <aside class="notes">
                            Obzvláště užitečná je metoda <code>format</code>,
                            která nahradí čísla v kudrnatých závorkách
                            za to, co dostane v argumentech:
                        </aside>
<pre>
vypis = '{0}×{1} je {2}'.format(3, 4, 3 * 4)
print(vypis)
</pre>
                        <aside class="notes">
                            Pokud použijeme pojmenované argumenty,
                            můžeme místo čísel psát i příslušná jména:
                        </aside>
<pre class="fragment">
print('Ahoj, {jmeno}!'.format(jmeno='Elvíro'))
</pre>
                        <aside class="notes">
                            Formátování se používá skoro všude, kde je
                            potřeba „hezky“ vypsat nějakou hodnotu.
                        </aside>
                    </section>
                </section>
                <section class="col-lg-12">
                    <section>
                        <h2>Sekání řetězců</h2>
                        <aside class="notes">
                            Teď se vrátíme k vybírání kousků řetězců.
                            Zkus, co dělá tenhle program:
                        </aside>
<pre>
retezec = 'čokoláda'
kousek = retezec[5:]
print(kousek)
</pre>
<details class="solution">
                        <aside class="notes">
                            Zápis <code>retezec[5:]</code> vybere
                            <em>podřetězec</em> od znaku číslo 7 dál.
                        </aside>
</details>
                    </section>
                    <section>
                        <aside class="notes">
                            Dá se použít i <code>retezec[:7]</code>,
                            který vybere všechno <em>až po</em> znak číslo 7.
                            Ale ne znak 7 samotný, takže
                            <code>retezec[:7] + retezec[7:] == retezec</code>.
                        </aside>
                        <aside class="notes">
                            Co asi udělá <code>retezec[2:7]</code>?<br>
                            A co <code>retezec[-4:]</code>?<br>
                        </aside>
<pre>
retezec = 'čokoláda'
print(retezec[:4])
print(retezec[2:5])
print(retezec[-4:])
</pre>
                    </section>
                    <section>
                        <a name="slicing-diagram"></a>
                        <aside class="notes">
                            Určování vhodných čísel, <em>indexů</em>,
                            občas vyžaduje trochu zamyšlení.<br>
                            U podobného „sekání“ (angl. <em>string slicing</em>)
                            je lepší číslovat „hranice“ mezi znaky.
                            Takhle:
                        </aside>
<pre>
  ╭───┬───┬───┬───┬───┬───┬───┬───╮
  │ Č │ o │ k │ o │ l │ á │ d │ a │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
  │   │   │   │   │   │   │   │   │
  0   1   2   3   4   5   6   7   8
 -8  -7  -6  -5  -4  -3  -2  -1

  ╰───────────────╯
  'čokoláda'[:4] == 'čoko'

          ╰───────────────╯
        'čokoláda'[2:6] == 'kolá'

                      ╰───────────╯
                      'čokoláda'[-3:] == 'áda'
</pre>
                    </section>
                    <section>
                        <div>
                            Zkus napsat funkci
                            <code>zamen(retezec, pozice, znak)</code>.
                        </div>
                        <div>
                            Tato funkce vrátí řetězec, který má na dané pozici
                            daný znak; jinak je stejný
                            jako původní <code>retezec</code>. Např:
                        </div>
<pre>
zamen('palec', 0, 'v') == 'valec'
zamen('valec', 2, 'j') == 'vajec'
</pre>
<details class="solution"><h3>Řešení</h3>
<pre>
def zamen(retezec, pozice, znak):
    """Zamění znak na dané pozici

    Vrátí řetězec, který má na dané pozici daný znak;
    jinak je stejný jako vstupní retezec
    """

    return retezec[:pozice] + znak + retezec[pozice + 1:]
</pre>
</details>
                    </section>
                </section>
            </div>

{% endblock %}
