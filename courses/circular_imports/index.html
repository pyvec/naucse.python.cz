{% extends 'templates/_base.html' %}

{% block title %}Poznámka k importu{% endblock %}

{% block content %}

<div class="slides row stuff">
                <section class="col-lg-12">
                    <section>
                        <h1>Poznámka o importování</h1>
                    </section>
                    <section>
                        <aside class="notes">
                            V domácích úlohách budeme rozdělovat 1D Piškvorky
                            na několik modulů.
                            Výsledek bude vypadat třeba nějak takhle:
                            (Šipky mezi moduly znázorňují importování.)
                        </aside>
<pre>
┌──────────────────╮  ┌───────────────╮  ┌──────────────────╮ 
│      ai.py       │◀-│ piskvorky.py  │◀-│    hra.py        │
├──────────────────┤  ├───────────────┤  ├──────────────────┤
│                  │  │ import ai     │  │ import piskvorky │
├──────────────────┤  ├───────────────┤  ├──────────────────┤
│ def tah_pocitace │  │ def vyhodnot  │  │                  │
│                  │  │ def tah       │  │                  │
└──────────────────┘  │ def tah_hrace │  └──────────────────┘
                      │               │
                      └───────────────┘  
                          ▲
                          │
                    ┌───────────────────╮
                    │ test_piskvorky.py │
                    ├───────────────────┤
                    │ import piskvorky  │
                    ├───────────────────┤
                    │ def test_...      │
                    │                   │
                    └───────────────────┘
</pre>
                    </section>
                    <section>
                        <aside class="notes">
                            Jenže funkce <code>tah_pocitace</code>
                            většinou potřebuje volat funkci <code>tah</code>.
                            Co s tím?
                            Můžeme importovat <code>ai</code>
                            z <code>piskvorky</code>, a zároveň
                            <code>piskvorky</code> z <code>ai</code>?
                        </aside>
<pre>
┌──────────────────╮  ┌───────────────╮
│      ai.py       │◀-│ piskvorky.py  │
├──────────────────┤-▶├───────────────┤
│ import piskvorky │  │ import ai     │
├──────────────────┤  ├───────────────┤
│ def tah_pocitace │  │ def vyhodnot  │
│                  │  │ def tah       │
└──────────────────┘  │ def tah_hrace │
                      │               │
                      └───────────────┘  
</pre>
                        <aside class="notes">
                            Můžeme se na to podívat z hlediska Pythonu,
                            který příkazy v souborech vykonává.
                            Když má spustit (nebo importovat) soubor
                            <code>piskvorky.py</code>, začne ho
                            zpracovávat ho řádek po řádku,
                            když tu (docela brzo) narazí na příkaz
                            <code>import ai</code>.
                            Otevře tedy soubor <code>ai.py</code>,
                            a začne ho zpracovávat, řádek po řádku.
                            Brzy narazí na příkaz
                            <code>import piskvorky</code>. Co teď?
                        </aside>
                        <aside class="notes">
                            Aby nenastala by situace podobná nekonečné smyčce –
                            jeden soubor by importoval druhý, druhý zase první,
                            a tak stále dokola,
                            udělá Python taková malý „podvod“:
                            když zjistí, že soubor <code>piskvorky.py</code>
                            už importuje, zpřístupní v modulu <code>ai</code>
                            modul <code>piskvorky</code> tak jak ho
                            má: nekompletní, bez většiny funkcí co v něm mají
                            být nadefinované.
                            A až potom, co dokončí import <code>ai.py</code>,
                            vrátí se k souboru <code>piskvorky.py</code>
                            a pokračuje v provádění příkazů <code>def</code>
                            které v něm jsou.
                            Takový nekompletní modul může být občas užitečný,
                            ale ve většině případů se chová skoro
                            nepředvídatelně a tudíž nebezpečně.
                        </aside>
                        <aside class="notes note">
                            Jinými slovy: když se dva moduly importují navzájem,
                            nemusí to fungovat podle očekávání.
                        </aside>
                        <aside class="notes">
                            Téhle situaci se budeme chtít
                            vyvarovat.
                        </aside>
                        <aside class="notes">
                            Jak na to? Máme dvě možnosti.
                        </aside>
                    </section>
                </section>
                <section class="col-lg-12">
                    <section>
                        <aside class="notes">
                            <h2 class="notes">Organizace modulů podle závislostí</h2>
                            První možnost je importovat funkci
                            <code>tah</code> v modulu <code>ai</code>,
                            a používat ji odtam.
                            To je jednoduché, ale nerespektuje účel modulu
                            <code>ai</code>, který má obsahovat jenom logiku
                            vybírání tahu počítače, a ne pomocné funkce které
                            můžou být potřeba i jinde.
                        </aside>
<pre>
┌──────────────────╮  ┌───────────────╮
│      ai.py       │◀-│ piskvorky.py  │
├──────────────────┤  ├───────────────┤
│                  │  │ import ai     │
├──────────────────┤  ├───────────────┤
│ def tah_pocitace │  │ def vyhodnot  │
│ def tah          │  │ def tah_hrace │
│                  │  │               │
└──────────────────┘  └───────────────┘
</pre>
                    </section>
                    <section>
                        <aside class="notes">
                            <h2 class="notes">Pomocný modul</h2>
                            Druhá možnost je defunovat nový, sdílený modul,
                            který se naimportuje jak z <code>piskvorky.py</code>
                            tak z <code>ai.py</code>.
                        </aside>
                        <aside class="notes">
                            Často se takový modul jmenuje
                            <code>util.py</code> (z angl. <em>utility</em>,
                            pomůcka, nástroj).
                        </aside>
<pre>
            ┌──────────────────╮
            │ util.py          │
            ├──────────────────┤
            ├──────────────────┤
            │ def tah          │
            └──────────────────┘
                ▲        ▲
                │        │
┌──────────────────╮  ┌───────────────╮
│      ai.py       │◀-│ piskvorky.py  │
├──────────────────┤  ├───────────────┤
│ import util      │  │ import ai     │
│                  │  │ import util   │
├──────────────────┤  ├───────────────┤
│ def tah_pocitace │  │ def vyhodnot  │
│                  │  │ def tah_hrace │
│                  │  │               │
└──────────────────┘  └───────────────┘
</pre>
                        <aside class="notes">
                            Nevýhoda pomocného modulu je ta,
                            že se z něj může stát neudržované „odkladiště“
                            všeho kódu, který byl jednou potřeba na dvou
                            nebo více místech.
                        </aside>
                        <aside class="notes">
                            Pro kterou z možností se rozhodnout, záleží
                            na situaci.
                            Programování není vždycky jen exaktní věda!
                        </aside>
                    </section>
                </section>
            </div>
{% endblock %}
