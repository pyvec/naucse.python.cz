<div class="row stuff">
                <section class="col-lg-12">
                    <h1>Grafika</h1>
                    <div>
                        Dnes si ukÃ¡Å¾eme, jak s Pythonem napsat grafickou aplikaci.
                    </div>
                    <div>
                        PouÅ¾ijeme knihovnu, kterÃ¡ nenÃ­ zabudovanÃ¡ pÅ™Ã­mo
                        v Pythonu (podobnÄ› jako pytest, kterÃ½ pouÅ¾Ã­vÃ¡me na
                        testovÃ¡nÃ­).
                        MusÃ­me si ji nejdÅ™Ã­v nainstalovat, a na to pouÅ¾ijeme
                        v zapnutÃ©m virtualenvu modul <code>pip</code> â€“
                        konkrÃ©tnÄ› pÅ™Ã­kaz
                        <code>python -m pip install pyglet</code>.
                        U mÄ› vypadÃ¡ instalace nÄ›jak takto:
                    </div>
<pre>
(venv)$ python -m pip install pyglet<span style="color:gray">
Collecting pyglet
  Downloading pyglet-1.2.4-py3-none-any.whl (964kB)
Installing collected packages: pyglet
Successfully installed pyglet-1.2.4</span>
</pre>
                    <div>
                        MÃ¡Å¡-li nainstalovÃ¡no, zkus napsat a spustit
                        nÃ¡sledujÃ­cÃ­ program. MÄ›lo by se objevit ÄernÃ©
                        okÃ½nko:
                    </div>
<pre>
import pyglet
window = pyglet.window.Window()
pyglet.app.run()
print('Hotovo!')
</pre>
                    <div class="note">
                        Jestli okÃ½nko nenÃ­ ÄernÃ© ale je v nÄ›m nÄ›jakÃ½
                        â€nepoÅ™Ã¡dekâ€œ, pÅ™edstavuj si zatÃ­m, Å¾e ÄernÃ© je.
                        StÃ¡vÃ¡ se to hlavnÄ› na poÄÃ­taÄÃ­ch s Mac OS a nÄ›kterÃ½mi
                        druhy Linuxu.
                        NeÅ¾ do okÃ½nka zaÄneme kreslit obrÃ¡zky, nepoÅ™Ã¡dek
                        uklidÃ­me.
                    </div>
                    <div>
                        Hotovo? PojÄme si vysvÄ›tlit, co se tu vlastnÄ› dÄ›je.
                    </div>
                    <h2>InteraktivnÃ­ programy</h2>
                    <div>
                        PodÃ­vejme se jeÅ¡tÄ› jednou jak zhruba vypadÃ¡ hlavnÃ­
                        program pro PiÅ¡kvorky, kterÃ½ jsme napsaly
                        na projektech.
                        V komentÃ¡Å™Ã­ch je napsanÃ©, co kterÃ¡ ÄÃ¡st kÃ³du dÄ›lÃ¡:
                    </div>
<pre>

def piskvorky1d():
    pole = '-' * 20                 # PÅ™Ã­prava hry
    while True:                     # PoÅ™Ã¡d dokola:
        pole = tah_hrace(pole)      # 1. Zeptej se na tah
        if vyhodnot(pole) != '-':   # 2. Zpracuj tah
            break
        print(pole)                 # 3. VypiÅ¡ stav hry

                                    # A znova:
        pole = tah_pocitace(pole)   # 1. Zeptej se na tah
        if vyhodnot(pole) != '-':   # 2. Zpracuj tah
            break
        print(pole)                 # 3. VypiÅ¡ stav hry
</pre>
                </section>
                <section class="col-lg-12">
                    <div>
                        V tomhle programu mÃ¡me dva druhy akcÃ­, kterÃ© se
                        pravidelnÄ› stÅ™Ã­dajÃ­.
                        Jakmile takovÃ¡ akce nastane, aÅ¥ vstup od ÄlovÄ›ka, nebo
                        od poÄÃ­taÄe, tak se zpracuje, a vÃ½slednÃ½ stav se
                        oznÃ¡mÃ­.
                    </div>
                    <div>
                        Podobnou strukturu â€reakcÃ­â€œ jsme pouÅ¾ily uÅ¾ dÅ™Ã­v,
                        tÅ™eba u hry kÃ¡men-nÅ¯Å¾ky-papÃ­r:
                        <ul>
                            <li>NÄ›jakÃ¡ pÅ™Ã­prava</li>
                            <li>
                                Dokud program nemÃ¡ skonÄit:
                                <ul>
                                    <li>NaÄti vstup</li>
                                    <li>NÄ›jak ten vstup vyhodnoÅ¥</li>
                                    <li>VypiÅ¡ vÃ½stup</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <div>
                        A podobnÄ› funguje vÄ›tÅ¡ina programÅ¯, kterÃ© nÄ›jakÃ½m
                        zpÅ¯sobem reagujÃ­ na vstup od uÅ¾ivatele, nebo i na jinÃ©
                        udÃ¡losti.
                    </div>
                    <div>
                        WebovÃ½ server ÄekÃ¡ na <em>poÅ¾adavek</em> (angl. request)
                        o webovou strÃ¡nku. KdyÅ¾ nÄ›jakÃ½ pÅ™ijme, zpracuje ho
                        (napÅ™. pÅ™eÄte pÅ™Ã­sluÅ¡nou strÃ¡nku z disku),
                        a jako vÃ½stup poÅ¡le odpovÄ›Ä.
                    </div>
                    <div>
                        SloÅ¾itÄ›jÅ¡Ã­ programy reagujÃ­ na spoustu druhÅ¯ udÃ¡lostÃ­,
                        ne jen na â€poÅ¾adavekâ€œ nebo â€tah hrÃ¡Äeâ€œ/â€tah poÄÃ­taÄeâ€œ.
                        Co se stane ve â€vyhodnocenÃ­ vstupuâ€œ pak zÃ¡visÃ­
                        na druhu udÃ¡losti.
                    </div>
                    <div>
                        WebovÃ½ prohlÃ­Å¾eÄ ÄekÃ¡ na kliknutÃ­ myÅ¡i nebo stisk klÃ¡vesy,
                        a zachovÃ¡ se podle nÄ›j â€“ tÅ™eba poÅ¡le pÅ™es internet
                        poÅ¾adavek vzdÃ¡lenÃ©mu serveru.
                        A potom ÄekÃ¡ na dalÅ¡Ã­ akci. MÅ¯Å¾e pÅ™ijÃ­t odpovÄ›Ä od
                        serveru, a aÅ¾ ta pÅ™ijde, vykreslÃ­ pÅ™Ã­sluÅ¡nou strÃ¡nku
                        na obrazovku. Nebo mÅ¯Å¾e uÅ¾ivatel zmÃ¡Äknout â€STOPâ€œ,
                        a poÅ¾adavek se zruÅ¡Ã­.
                    </div>
                    <div>
                        TextovÃ½ editor ÄekÃ¡ na rÅ¯znÃ© druhy vstupu z klÃ¡vesnice
                        Äi myÅ¡i, a kaÅ¾dÃ½ musÃ­ nÄ›jak zpracovat.
                    </div>
                    <div>
                        ProstÄ›, podobnÃ¡ struktura programu â€“ smyÄka kterÃ¡
                        naÄte vstup, zpracuje ho, a vyprodukuje vÃ½stup â€“ je
                        velice uÅ¾iteÄnÃ¡.
                        Å˜Ã­kÃ¡ se jÃ­ <em>smyÄka udÃ¡lostÃ­</em>
                        (angl. <em>event loop</em>),
                        a programy na nÃ­ postavenÃ© jsou
                        <em>Å™Ã­zenÃ© udÃ¡lostmi</em> (angl. <em>event-driven</em>).
                    </div>
                </section>
                <section class="col-lg-12">
                    <div>
                        ProgramÃ¡toÅ™i jsou lÃ­nÃ­.
                        KdyÅ¾ je nÄ›co uÅ¾iteÄnÃ© pro vÃ­ce programÅ¯, nebÃ½vÃ¡
                        zvykem, Å¾e to kaÅ¾dÃ½ programÃ¡tor v kaÅ¾dÃ©m programu
                        opakuje.
                        NapÃ­Å¡e se to jednou a dobÅ™e, zabalÃ­ se to jako tzv.
                        <em>knihovna</em> (angl. <em>library</em>),
                        a ostatnÃ­ to pak mÅ¯Å¾ou pouÅ¾Ã­vat.
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Pyglet ğŸ·</h2>
                    <div>
                        Jedna z takovÃ½ch knihoven je Pyglet.
                        Obsahuje kromÄ› smyÄky udÃ¡lostÃ­ taky funkce na
                        vykreslovÃ¡nÃ­ 2D grafiky (pomocÃ­ jinÃ© knihovny zvanÃ©
                        OpenGL), nebo tÅ™eba naÄÃ­tÃ¡nÃ­ udÃ¡lostÃ­ z klÃ¡vesnice
                        a myÅ¡i.
                    </div>
                    <div>
                        PojÄme se vrÃ¡tit k progrÃ¡mku, kterÃ½ ukazuje okno:
                    </div>
<pre>
import pyglet
window = pyglet.window.Window()
pyglet.app.run()
print('Hotovo!')
</pre>
                    <div>
                        CelÃ¡ smyÄka udÃ¡lostÃ­ se skrÃ½vÃ¡ ve funkci
                        <code>pyglet.app.run()</code>.
                        NaÄtenÃ­ vstupu (napÅ™. z klÃ¡vesnice) dÄ›lÃ¡ Pyglet sÃ¡m,
                        ale jejich zpracovÃ¡nÃ­ a vykreslenÃ­ vÃ½sledkÅ¯
                        uÅ¾ je pro kaÅ¾dÃ½ program jinÃ©, takÅ¾e si je budeme muset
                        naprogramovat samy.
                    </div>
                    <div>
                        ZatÃ­m pro nÃ¡s Pyglet zpracovÃ¡vÃ¡ jen dvÄ› udÃ¡losti:
                        zavÅ™enÃ­ okna (tlaÄÃ­tkem â€âœ•â€œ, kterÃ© k okÃ½nkÅ¯m pÅ™idÃ¡vÃ¡
                        operaÄnÃ­ systÃ©m), a stisk klÃ¡vesy <code>Esc</code>,
                        kterÃ½ taky zavÅ™e okno.
                        Po zavÅ™enÃ­ okna skonÄÃ­ smyÄka udÃ¡lostÃ­
                        (funkce <code>pyglet.app.run()</code>)
                        a program mÅ¯Å¾e pokraÄovat.
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Text</h2>
                    <div>
                        KlÃ¡vesa <code>esc</code> nenÃ­ pÅ™Ã­liÅ¡ zajÃ­mavÃ¡.
                        Zkusme reagovat i na jinÃ© klÃ¡vesy.
                    </div>
                    <div>
                        V Pygletu se na udÃ¡losti reaguje tak, Å¾e napÃ­Å¡eÅ¡
                        funkci, a pak ji <em>zaregistrujeÅ¡</em> (angl. register) â€“ Å™ekneÅ¡
                        Pygletu, aby ji vÅ¾dy v pravÃ½ Äas zavolal.
                        UdÃ¡losti, kterÃ¡ nastane kdyÅ¾ uÅ¾ivatel pÃ­Å¡e na klÃ¡vesnici,
                        se v Pygletu Å™Ã­kÃ¡ <code>on_text</code>,
                        a zpracovÃ¡vÃ¡ se takto:
                    </div>
<pre><span style="color:gray">
import pyglet
window = pyglet.window.Window()</span>

def zpracuj_text(text):
    print(text)

window.push_handlers(on_text=zpracuj_text)<span style="color:gray">

pyglet.app.run()</span>
</pre>
                    <div>
                        Co to dÄ›lÃ¡? <code>window.push_handlers(on_text=zpracuj_text)</code>
                        Å™ekne Pygletu, Å¾e kdyÅ¾ uÅ¾ivatel nÄ›co napÃ­Å¡e do naÅ¡eho okna,
                        mÃ¡ Pyglet zavolat funkci <code>zpracuj_text</code>.
                        Tahle funkce pak dostane jako argument text, kterÃ½ uÅ¾ivatel napsal.
                    </div>
                    <div>
                        VÅ¡imni si, Å¾e pÅ™i registraci nepÃ­Å¡eme
                        <code>zpracuj_text</code> se zÃ¡vorkami, aÄkoli jsme si
                        <a href="{{ lesson_url('beginners/functions') }}">kdysi</a>
                        Å™Ã­kali, Å¾e funkce se majÃ­ volat.
                        VzpomÃ­nÃ¡Å¡ na tenhle pÅ™Ã­klad? MoÅ¾nÃ¡ ti tehdy pÅ™ipadal
                        zvlÃ¡Å¡tnÃ­.
                    </div>
<pre>
from math import sin
print(sin(1))
print(sin)
print(sin + 1)
</pre>
                    <div>
                        TeÄ, kdyÅ¾ znÃ¡me kromÄ› ÄÃ­sel, Å™etÄ›zcÅ¯ a
                        <code>True</code>/<code>False</code> i soubory, seznamy
                        <i>n</i>-tice, a kdo vÃ­ jakÃ© jinÃ© typy, si mÅ¯Å¾eme Å™Ã­ct,
                        Å¾e funkce je v Pythonu hodnota jako kaÅ¾dÃ¡ jinÃ¡.
                        ÄŒÃ­sla se dajÃ­ nÃ¡sobit, Å™etÄ›zce zapisovat do souboru,
                        ze souborÅ¯ se dÃ¡ ÄÃ­st â€“ a funkce jsou zvlÃ¡Å¡tnÃ­ jen tÃ­m,
                        Å¾e se dajÃ­ zavolat.
                        NeÅ¾ ale takovou funkci zavolÃ¡me, mÅ¯Å¾eme ji, tu samotnou
                        funkci, tÅ™eba pÅ™iÅ™adit do promÄ›nnÃ©:
                    </div>
<pre>
vypis = print
vypis("Ahoj svÄ›te!")
</pre>
                    <div>
                        nebo pÅ™edat jako argument jinÃ© funkci:
                    </div>
<pre>
print(print)
</pre>
                    <div>
                        No a funkce <code>window.push_handlers</code> je pÅ™Ã­mo
                        dÄ›lanÃ¡ na to, Å¾e jÃ­ pÅ™edÃ¡Å¡ funkci.
                        ProÄ?
                        Pyglet nepotÅ™ebuje jeden vÃ½sledek funkce
                        <code>zpracuj_text</code> â€“ ten moc k niÄemu nenÃ­.
                        A navÃ­c tu funkci teÄ ani nemÅ¯Å¾eme zavolat; nemÃ¡me
                        vhodnÃ½ argument <code>text</code>.
                        Proto Pygletu dÃ¡me samotnou funkci, kterou bude sÃ¡m
                        volat, kdykoli uÅ¾ivatel stiskne klÃ¡vesu.
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>ÄŒas â²</h2>
                    <div>
                        JeÅ¡tÄ› jednu udÃ¡lost zpracujme,
                        neÅ¾ se pÅ™esuneme ke grafice.
                    </div>
                    <div>
                        Bude to takzvanÃ½ <em>tik</em> hodin
                        (angl. <em>clock tick</em>).
                        To je udÃ¡lost, kterÃ¡ nastÃ¡vÃ¡ pravidelnÄ› po nÄ›jakÃ©m Äase.
                    </div>
                    <div>
                        Funkce pro tiky se registruje trochu jinak neÅ¾
                        <code>on_text</code>:
                    </div>
<pre><span style="color:gray">
import pyglet
window = pyglet.window.Window()</span>

def tik(t):
    print(t)

pyglet.clock.schedule_interval(tik, 1/30)<span style="color:gray">

def zpracuj_text(text):
    print(text)

window.push_handlers(on_text=zpracuj_text)

pyglet.app.run()</span>
</pre>
                    <div>
                        Co to dÄ›lÃ¡? <code>pyglet.clock.schedule_interval(tik, 30)</code>
                        Å™ekne Pygletu, Å¾e mÃ¡ zavolat funkci <code>tik</code> kaÅ¾dou
                        tÅ™icetinu (<code>1/30</code>) vteÅ™iny.
                    </div>
                    <div>
                        A funkce <code>tik</code> dostane jeden argument â€“ kolik Äasu
                        uplynulo od poslednÃ­ho zavolÃ¡nÃ­.
                        VÄ›tÅ¡inou to nenÃ­ pÅ™esnÄ› 1/30 vteÅ™iny, ale nÄ›co vÃ­c.
                        PoÄÃ­taÄ mÃ¡ i jinÃ© vÄ›ci na prÃ¡ci, takÅ¾e se k naÅ¡Ã­ aplikaci
                        nemusÃ­ dostat hned; a taky Pythonu trvÃ¡ nÄ›jakou tu
                        tisÃ­cinu vteÅ™iny neÅ¾ zaÅ™Ã­dÃ­ samotnÃ© zavolÃ¡nÃ­ naÅ¡Ã­ funkce.
                    </div>
                    <div class="note">
                        <div>
                            A proÄ vlastnÄ› tÅ™icetina vteÅ™iny?
                            Je to kvÅ¯li tomu, Å¾e potom budeme stavÄ›t animace.
                            KdyÅ¾ se nÃ¡m pÅ™ed oÄima vystÅ™Ã­dÃ¡ 30 obrÃ¡zkÅ¯ za vteÅ™inu,
                            mozek si je spojÃ­ a vznikne iluze plynulÃ©ho pohybu.
                            <br>
                            VÄ›tÅ¡ina filmÅ¯ pouÅ¾Ã­vÃ¡ jen 24 obrÃ¡zkÅ¯ za vteÅ™inu;
                            realistickÃ© 3D hry aÅ¾ 60.
                        </div>
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>VykreslovÃ¡nÃ­</h2>
                    <img src="{{ static('had.png') }}" alt=""
                         style="display:block;float:right;">
                    <div>
                        Program kterÃ½ vypisuje na terminÃ¡l spoustu ÄÃ­sel,
                        nenÃ­ asi zas tak zajÃ­mavÃ½.
                        TÃ©ma tÃ©hle strÃ¡nky je ale grafika, tak se zaÄnÄ›me od
                        terminÃ¡lu odpoutÃ¡vat. PojÄme kreslit.
                    </div>
                    <div>
                        Najdi si na internetu nÄ›jakÃ½ obrÃ¡zek. Ne moc velkÃ½,
                        tak 3cm, aÅ¥ je kolem nÄ›j v naÅ¡em ÄernÃ©m okÃ½nku dost
                        mÃ­sta, a nejlÃ©pe ve formÃ¡tu PNG. ZaÄni tÅ™eba na
                        <a href="https://www.google.cz/search?tbs=ift:png&amp;tbm=isch&amp;q=snake+icon">tÃ©hle strÃ¡nce</a>.
                        UloÅ¾ si ho do adresÃ¡Å™e, odkud spouÅ¡tÃ­Å¡ svÅ¯j PythonÃ­
                        program. JÃ¡ mÃ¡m tÅ™eba obrÃ¡zek hada v souboru <code>had.png</code>.
                    </div>
                    <div>
                        Pak obrÃ¡zek vykresli (pouÅ¾ij jmÃ©no souboru se svÃ½m obrÃ¡zkem):
                    </div>
<pre><span style="color:gray">
import pyglet
window = pyglet.window.Window()

def tik(t):
    print(t)

pyglet.clock.schedule_interval(tik, 1/30)

def zpracuj_text(text):
    print(text)</span>

obrazek = pyglet.image.load(<span style="color:red">'had.png'</span>)
had = pyglet.sprite.Sprite(obrazek)

def vykresli():
    window.clear()
    had.draw()<span style="color:gray">

window.push_handlers(
    on_text=zpracuj_text,</span>
    on_draw=vykresli,<span style="color:gray">
)

pyglet.app.run()</span>
</pre>
                    <div>
                        Povedlo se?
                    </div>
                    <div>
                        VysvÄ›tleme si, co se tady dÄ›je:
                        <ul>
                            <li>
                                <code>obrazek = pyglet.image.load('had.png')</code>
                                naÄte ze souboru obrÃ¡zek
                            </li>
                            <li>
                                <code>had = pyglet.sprite.Sprite(obrazek)</code>
                                vytvoÅ™Ã­ speciÃ¡lnÃ­ objekt <a href="https://cs.wikipedia.org/wiki/Sprite_%28po%C4%8D%C3%ADta%C4%8Dov%C3%A1_grafika%29">Sprite</a>,
                                kterÃ½ urÄuje, Å¾e tento obrÃ¡zek chceme â€posaditâ€œ
                                na urÄitÃ© mÃ­sto v ÄernÃ©m okÃ½nku.
                                KdyÅ¾ neudÄ›lÃ¡me nic dalÅ¡Ã­ho, bude obrÃ¡zek Äekat v levÃ©m rohu.
                            </li>
                            <li>
                                Funkce <code>vykresli()</code>
                                se starÃ¡ vykreslenÃ­ okna â€“ vÃ½stup naÅ¡eho programu.
                                VolÃ¡ se vÅ¾dycky, kdyÅ¾ je potÅ™eba okno pÅ™ekreslit â€“
                                napÅ™Ã­klad kdyÅ¾ okno minimalizujeÅ¡ a pak vrÃ¡tÃ­Å¡,
                                nebo pÅ™esuneÅ¡ ÄÃ¡steÄnÄ› ven z obrazovky,
                                a pak dÃ¡Å¡ zase zpÄ›t.
                                A nebo kdyÅ¾ budeme nÄ›co animovat.
                                <div class="note">
                                    NÄ›kterÃ© operaÄnÃ­ systÃ©my si pamatujÃ­ i obsah oken,
                                    kterÃ© nejsou vidÄ›t, ale nenÃ­ radno na to spolÃ©hat.
                                </div>
                            </li>
                            <li>
                                <code>window.clear()</code>
                                vyÄistÃ­ okno â€“ natÅ™e ho Äernou barvou, a smaÅ¾e
                                vÅ¡echno, co v nÄ›m bylo pÅ™edtÃ­m.
                                <div class="note">
                                    Na spoustÄ› poÄÃ­taÄÅ¯ tohle nenÃ­ potÅ™eba.
                                    Ale je lepÅ¡Ã­ psÃ¡t programy tak, aby
                                    bÄ›Å¾ely sprÃ¡vnÄ› kdekoli.
                                </div>
                            </li>
                            <li>
                                <code>had.draw()</code>
                                nakreslÃ­ obrÃ¡zek pomocÃ­ pÅ™edpÅ™ipravenÃ©ho
                                <em>spritu</em> <code>had</code>.
                            </li>
                            <li>
                                <code>window.push_handlers(on_draw=vykresli)</code>
                                zaregistruje funkci <code>vykresli</code> â€“ Å™ekne
                                Pygletu, aby ji volal vÅ¾dy kdyÅ¾ je tÅ™eba.
                                <br>
                                KdyÅ¾ potÅ™ebujeme zaregistrovat pro jedno okno
                                vÃ­c funkcÃ­ na obsluhu udÃ¡lostÃ­,
                                dajÃ­ se dÃ¡t funkci <code>push_handlers</code>
                                takhle najednou.
                            </li>
                        </ul>
                    </div>
                    <div>
                        JakÃ©koli kreslenÃ­ se <em>musÃ­</em> dÄ›lat v rÃ¡mci kreslÃ­cÃ­ funkce,
                        kterou Pyglet volÃ¡ z <code>on_draw</code>.
                        Jinde funkce jako <code>clear</code> a <code>draw</code>
                        nebudou fungovat sprÃ¡vnÄ›.
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Animace</h2>
                    <div>
                        PojÄme si teÄ s naÅ¡Ã­m Spritem trochu pohrÃ¡t.
                    </div>
                    <div>
                        Do funkce <code>zpracuj_text</code> dej mÃ­sto printu tento pÅ™Ã­kaz:
                    </div>
<pre><span style="color:gray">
def zpracuj_text(text):</span>
    had.x = 150
</pre>
                    <div>
                        NÃ¡Å¡ Sprite mÃ¡ <em>atribut</em> (angl. attribute)
                        <code>x</code>, kterÃ½ urÄuje jeho <i>x</i>-ovou souÅ™adnici â€“
                        jak moc je vpravo od okraje okna.
                        Tenhle atribut se dÃ¡ nastavit, jak budeÅ¡ chtÃ­t â€“ nejÄastÄ›ji
                        v reakci na nÄ›jakou udÃ¡lost, ale Äasto se nastavuje
                        i na zaÄÃ¡tku programu.
                    </div>
                    <div>
                        ZajÃ­mavÃ© je zkusit k <code>x</code> nÄ›co pÅ™iÄÃ­st
                        pÅ™i kaÅ¾dÃ©m tiknutÃ­ hodin.
                        DokÃ¡Å¾eÅ¡ pÅ™edpovÄ›dÄ›t, co udÄ›lÃ¡ tenhle kÃ³d?
                    </div>
<pre>
def tik(t):
    had.x = had.x + t * 20
</pre>
                    <div>
                        NebojÃ­Å¡-li se matematiky, naimportuj <code>math</code>
                        a nech obrÃ¡zek, aÅ¥ se pohybuje podle nÄ›jakÃ© funkce:
                    </div>
<pre>
def tik(t):
    had.x = had.x + t * 20
    had.y = 20 + 20 * math.sin(had.x / 5)
</pre>
                    <div>
                        Co se stane, kdyÅ¾ zaÄneÅ¡ mÄ›nit ta ÄÃ­sla?
                    </div>
                    <div>
                        Co se stane, kdyÅ¾ zkusÃ­Å¡ podobnÄ› nastavovat atribut
                        <code>rotation</code>?
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Zavolej pozdÄ›ji</h2>
                    <img src="{{ static('had2.png') }}" alt=""
                        style="display:block;float:right;">
                    <div>
                        Pyglet umÃ­ kromÄ› opakovanÃ©ho â€tikÃ¡nÃ­â€œ zavolat funkci
                        jednorÃ¡zovÄ›, za urÄitou dobu.
                    </div>
                    <div>
                        StÃ¡hni si (nebo vytvoÅ™) druhÃ½ obrÃ¡zek. JÃ¡ mÃ¡m druhÃ©ho
                        hada, tentokrÃ¡t s trochu natoÄenou hlavou a ocasem.
                    </div>
                    <div>
                        AÅ¾ budeÅ¡ mÃ­t obrÃ¡zek v  adresÃ¡Å™i s programem,
                        pÅ™idej tÄ›snÄ› pÅ™ed <code>pyglet.app.run()</code>
                        tenhle kus kÃ³du:
                    </div>
<pre>
obrazek2 = pyglet.image.load(<span style="color:red">'had2.png'</span>)

def zmen(t):
    had.image = obrazek2

pyglet.clock.schedule_once(zmen, 1)

</pre>
                    <div>
                        VolÃ¡nÃ­ <code>schedule_once(zmen, 1)</code> Å™Ã­kÃ¡ Pygletu,
                        Å¾e za jednu vteÅ™inu mÃ¡ zavolat funkci <code>zmen</code>.
                        A funkce zmÄ›nÃ­ obrÃ¡zek â€“ stejnÄ› jako se pÅ™edtÃ­m mÄ›nily
                        souÅ™adnice.
                    </div>
                    <hr>
                    <div>
                        <code>schedule_once</code> se dÃ¡ volat i v rÃ¡mci
                        obsluhy jinÃ© udÃ¡losti. Zkus funkci <code>zmen</code>
                        nahradit tÃ­mhle:
                    </div>
<pre>
def zmen(t):
    had.image = obrazek2
    pyglet.clock.schedule_once(zmen_zpatky, 0.2)

def zmen_zpatky(t):
    had.image = obrazek
    pyglet.clock.schedule_once(zmen, 0.2)
</pre>
                </section>
                <section class="col-lg-12">
                    <h2>Klik ğŸ­</h2>
                    <div>
                        PoslednÃ­ vÄ›c, na kterou se tady nauÄÃ­me reagovat,
                        je klikÃ¡nÃ­.
                        TÄ›snÄ› pÅ™ed <code>window.push_handlers</code>
                        napiÅ¡ funkci:
                    </div>
<pre>
def klik(x, y, tlacitko, mod):
    had.x = x
    had.y = y
</pre>
                    <div>
                        â€¦ a pak v <code>push_handlers</code> ji zaregistruj
                        pomocÃ­ Å™Ã¡dku <code>on_mouse_press=klik,</code>.
                    </div>
                    <div>
                        Co znamenÃ¡ kterÃ½ argument, to zkus zjistit sama.
                        <div class="note">
                            NÃ¡povÄ›da:
                            <ul>
                                <li>
                                    Dokud pÅ™Ã­kazovou Å™Ã¡dku neopustÃ­Å¡ ÃºplnÄ›,
                                    bude fungovat <code>print</code>!
                                    Kdykoliv budeÅ¡ chtÃ­t zjistit nÄ›jakou
                                    hodnotu, prostÄ› si ji vypiÅ¡.
                                </li>
                                <li>Kolik mÃ¡ myÅ¡ tlaÄÃ­tek?</li>
                                <li>Jak se projevÃ­ Shift+klik?</li>
                            </ul>
                        </div>
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>PokraÄovÃ¡nÃ­ pÅ™Ã­Å¡tÄ›</h2>
                    <div>
                        KoukÃ¡m Å¾e kÃ³du uÅ¾ je dnes tak akorÃ¡t na ukonÄenÃ­ lekce:
                    </div>
<pre>
import math

import pyglet

window = pyglet.window.Window()

def tik(t):
    had.x = had.x + t * 20

pyglet.clock.schedule_interval(tik, 1/30)

def zpracuj_text(text):
    had.x = 150
    had.rotation = had.rotation + 10

obrazek = pyglet.image.load('had.png')
had = pyglet.sprite.Sprite(obrazek, x=10, y=10)

def vykresli():
    window.clear()
    had.draw()

def klik(x, y, tlacitko, mod):
    print(tlacitko, mod)
    had.x = x
    had.y = y

window.push_handlers(
    on_text=zpracuj_text,
    on_draw=vykresli,
    on_mouse_press=klik,
)

obrazek2 = pyglet.image.load('had2.png')

def zmen(t):
    had.image = obrazek2
    pyglet.clock.schedule_once(zmen_zpatky, 0.2)

def zmen_zpatky(t):
    had.image = obrazek
    pyglet.clock.schedule_once(zmen, 0.2)

pyglet.clock.schedule_once(zmen, 0.2)

pyglet.app.run()
</pre>
                    <div>
                        Se vstupem z klÃ¡vesnice a myÅ¡i, ÄasovÃ¡nÃ­m, a vykreslovÃ¡nÃ­m
                        Spritu si vystaÄÃ­Å¡ u leckterÃ© hry nebo grafickÃ© aplikace.
                    </div>
                    <div>
                        To, co jsme tu probraly, a pÃ¡r vÄ›cÃ­ navÃ­c,
                        je shrnuto v <a href="https://github.com/pyvec/cheatsheets/raw/master/pyglet/pyglet-basics-cs.pdf">
                        tahÃ¡ku na Pyglet</a>, kterÃ½ si mÅ¯Å¾eÅ¡ stÃ¡hnout
                        a vytisknout.
                    </div>
                    <div>
                        AÅ¾ budeÅ¡ nÄ›jakou dÄ›lat, zkus udrÅ¾ovat
                        stav aplikace v seznamech a n-ticÃ­ch (pÅ™Ã­padnÄ›
                        slovnÃ­cÃ­ch a tÅ™Ã­dÃ¡ch, kterÃ© se nauÄÃ­me pozdÄ›ji).
                        Jedna funkce by mÄ›la umÄ›t takovÃ½ stav vykreslit, a
                        jinÃ© s nÃ­m pak budou manipulovat.
                        Tyhle dvÄ› sady funkcÃ­ mÅ¯Å¾eÅ¡ mÃ­t i v jinÃ½ch souborech,
                        aby se nezapletly dohromady.
                    </div>
                    <div>
                        ZajÃ­mÃ¡-li tÄ› toto tÃ©ma, zkus si zahrÃ¡t pÅ™iloÅ¾enou hru
                        <a href="{{ static('pong.py') }}">
                            Pong
                        </a>,
                        kterÃ¡ ukazuje nÄ›kterÃ© dalÅ¡Ã­
                        moÅ¾nosti Pygletu: psanÃ­ textu, kreslenÃ­ obdÃ©lnÃ­kÅ¯,
                        a obsluhu jednotlivÃ½ch klÃ¡ves (napÅ™. Å¡ipek).
                        Na prvnÃ­ pohled mÅ¯Å¾e jejÃ­ kÃ³d vypadat sloÅ¾itÄ›,
                        ale zkus si k nÄ›mu sednout, a s pomocÃ­ komentÃ¡Å™Å¯
                        ho pochopit.
                        Kdyby komentÃ¡Å™e nestaÄily, jsou k Pongu pÅ™ipravenÃ©
                        i <a href="{{ lesson_url('projects/pong') }}">podrobnÃ© materiÃ¡ly</a>.
                    </div>
                    <div>
                        A chceÅ¡-li se do Pygletu ponoÅ™it hloubÄ›ji,
                        existuje pro nÄ›j <a href="http://pyglet.readthedocs.org/en/latest/index.html">dokumentace</a>.
                        Nebude-li ti v nÃ­ nÄ›co jasnÃ©, zeptej se!
                    </div>
                </section>
            </div>
