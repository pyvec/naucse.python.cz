<html>

    <head>
        <meta charset="utf-8">
        <title>PyLadies 12-01 â€“ Grafika</title>

        <link rel="stylesheet" href="../css/bootstrap.css">
        <link rel="stylesheet" href="../css/pyladies.css">
    </head>

    <body class="no-reveal">

        <div class="container">
            <div class="no-reveal header">
                <div style="text-align:center;">
                    <img src="had.gif">
                </div>
                <h3 class="text-muted" id="show-all">PyLadies Brno</h3>
            </div>
            <div class="row stuff">
                <section class="col-lg-12">
                    <h1>Grafika</h1>
                    <div>
                        Dnes si ukÃ¡Å¾eme, jak s Pythonem napsat grafickou aplikaci.
                    </div>
                    <div>
                        PouÅ¾ijeme knihovnu, kterÃ¡ nenÃ­ zabudovanÃ¡ pÅ™Ã­mo
                        v Pythonu (podobnÄ› jako pytest, kterÃ½ pouÅ¾Ã­vÃ¡me na
                        testovÃ¡nÃ­).
                        MusÃ­me si ji nejdÅ™Ã­v nainstalovat, a na to pouÅ¾ijeme
                        v zapnutÃ©m virtualenvu modul <code>pip</code> â€“
                        konkrÃ©tnÄ› pÅ™Ã­kaz
                        <code>python -m pip install pyglet</code>.
                        U mÄ› vypadÃ¡ instalace nÄ›jak takto:
                    </div>
<pre>
(venv)$ python -m pip install pyglet<span style="color:gray">
Collecting pyglet
  Downloading pyglet-1.2.4-py3-none-any.whl (964kB)
Installing collected packages: pyglet
Successfully installed pyglet-1.2.4</span>
</pre>
                    <div>
                        MÃ¡Å¡-li nainstalovÃ¡no, zkus napsat a spustit
                        nÃ¡sledujÃ­cÃ­ program. MÄ›lo by se objevit okÃ½nko:
                    </div>
<pre>
import pyglet
window = pyglet.window.Window()
pyglet.app.run()
print('Hotovo!')
</pre>
                    <div>
                        Hotovo? PojÄme si vysvÄ›tlit, co se tu vlastnÄ› dÄ›je.
                    </div>
                    <h2>InteraktivnÃ­ programy</h2>
                    <div>
                        PodÃ­vejme se jeÅ¡tÄ› jednou jak zhruba vypadÃ¡ hlavnÃ­
                        program pro PiÅ¡kvorky, kterÃ½ jsme napsaly
                        na Ãºkolech.
                        V komentÃ¡Å™Ã­ch je napsanÃ©, co kterÃ¡ ÄÃ¡st kÃ³du dÄ›lÃ¡:
                    </div>
<pre>

def piskvorky1d():
    pole = '-' * 20                 # PÅ™Ã­prava hry
    while True:                     # PoÅ™Ã¡d dokola:
        pole = tah_hrace(pole)      # 1. Zeptej se na tah
        if vyhodnot(pole) != '-':   # 2. Zpracuj tah
            break
        print(pole)                 # 3. VypiÅ¡ stav hry

                                    # A znova:
        pole = tah_pocitace(pole)   # 1. Zeptej se na tah
        if vyhodnot(pole) != '-':   # 2. Zpracuj tah
            break
        print(pole)                 # 3. VypiÅ¡ stav hry
</pre>
                </section>
                <section class="col-lg-12">
                    <div>
                        V tomhle programu mÃ¡me dva druhy akcÃ­, kterÃ© se
                        pravidelnÄ› stÅ™Ã­dajÃ­.
                        Jakmile takovÃ¡ akce nastane, aÅ¥ vstup od ÄlovÄ›ka, nebo
                        od poÄÃ­taÄe, tak se zpracuje, a vÃ½slednÃ½ stav se
                        oznÃ¡mÃ­.
                    </div>
                    <div>
                        Podobnou strukturu â€reakcÃ­â€ jsme pouÅ¾ily uÅ¾ dÅ™Ã­v,
                        tÅ™eba u hry kÃ¡men-nÅ¯Å¾ky-papÃ­r:
                        <ul>
                            <li>NÄ›jakÃ¡ pÅ™Ã­prava</li>
                            <li>Dokud program nemÃ¡ skonÄit:</li>
                            <ul>
                                <li>NaÄti vstup</li>
                                <li>NÄ›jak ten vstup vyhodnoÅ¥</li>
                                <li>VypiÅ¡ vÃ½stup</li>
                            </ul>
                        </ul>
                    </div>
                    <div>
                        A podobnÄ› funguje vÄ›tÅ¡ina programÅ¯, kterÃ© nÄ›jakÃ½m
                        zpÅ¯sobem reagujÃ­ na vstup od uÅ¾ivatele, nebo i na jinÃ©
                        udÃ¡losti.
                    </div>
                    <div>
                        WebovÃ½ server ÄekÃ¡ na <em>poÅ¾adavek</em> (angl. request)
                        o webovou strÃ¡nku. KdyÅ¾ nÄ›jakÃ½ pÅ™ijme, zpracuje ho
                        (napÅ™. pÅ™eÄte pÅ™Ã­sluÅ¡nou strÃ¡nku z disku),
                        a jako vÃ½stup poÅ¡le odpovÄ›Ä.
                    </div>
                    <div>
                        SloÅ¾itÄ›jÅ¡Ã­ programy reagujÃ­ na spoustu druhÅ¯ udÃ¡lostÃ­
                        (jen na â€poÅ¾adavekâ€ nebo â€tah hrÃ¡Äeâ€/â€tah poÄÃ­taÄeâ€
                        a co se stane ve â€vyhodnocenÃ­ vstupuâ€ pak zÃ¡visÃ­
                        na druhu udÃ¡losti.
                    </div>
                    <div>
                        WebovÃ½ prohlÃ­Å¾eÄ ÄekÃ¡ na kliknutÃ­ myÅ¡i nebo stisk klÃ¡vesy,
                        a zachovÃ¡ se podle nÄ›j â€“ tÅ™eba poÅ¡le pÅ™es internet
                        poÅ¾adavek vzdÃ¡lenÃ©mu serveru.
                        A potom ÄekÃ¡ na dalÅ¡Ã­ akci. MÅ¯Å¾e pÅ™ijÃ­t odpovÄ›Ä od
                        serveru, a aÅ¾ ta pÅ™ijde, vykreslÃ­ pÅ™Ã­sluÅ¡nou strÃ¡nku
                        na obrazovku. Nebo mÅ¯Å¾e uÅ¾ivatel zmÃ¡Äknout â€STOPâ€,
                        a poÅ¾adavek se zruÅ¡Ã­.
                    </div>
                    <div>
                        TextovÃ½ editor ÄekÃ¡ na rÅ¯znÃ© druhy vstupu z klÃ¡vesnice
                        Äi myÅ¡i, a kaÅ¾dÃ½ musÃ­ nÄ›jak zpracovat.
                    </div>
                    <div>
                        ProstÄ›, podobnÃ¡ struktura programu â€“ smyÄka kterÃ¡
                        naÄte vstup, zpracuje ho, a vyprodukuje vÃ½stup â€“ je
                        velice uÅ¾iteÄnÃ¡.
                        Å˜Ã­kÃ¡ se jÃ­ <em>smyÄka udÃ¡lostÃ­</em> (angl. event loop),
                        a programy na nÃ­ postavenÃ© jsou
                        <em>Å™Ã­zenÃ© udÃ¡lostmi</em> (angl. event-driven).
                    </div>
                </section>
                <section class="col-lg-12">
                    <div>
                        ProgramÃ¡toÅ™i jsou lÃ­nÃ­.
                        KdyÅ¾ je nÄ›co uÅ¾iteÄnÃ© pro vÃ­ce programÅ¯, nebÃ½vÃ¡
                        zvykem, Å¾e to kaÅ¾dÃ½ programÃ¡tor v kaÅ¾dÃ©m programu
                        opakuje.
                        NapÃ­Å¡e se to jednou a dobÅ™e, zabalÃ­ se to jako knihovna
                        a ostatnÃ­ to pak mÅ¯Å¾ou pouÅ¾Ã­vat.
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Pyglet ğŸ·</h2>
                    <div>
                        Jedna z takovÃ½ch knihoven je Pyglet.
                        Obsahuje kromÄ› smyÄky udÃ¡lostÃ­ taky funkce na
                        vykreslovÃ¡nÃ­ 2D grafiky (pomocÃ­ knihovny OpenGL),
                        nebo tÅ™eba naÄÃ­tÃ¡nÃ­ udÃ¡lostÃ­ z klÃ¡vesnice a myÅ¡i.
                    </div>
                    <div>
                        PojÄme se vrÃ¡tit k progrÃ¡mku, kterÃ½ ukazuje okno:
                    </div>
<pre>
import pyglet
window = pyglet.window.Window()
pyglet.app.run()
print('Hotovo!')
</pre>
                    <div>
                        CelÃ¡ smyÄka udÃ¡lostÃ­ se skrÃ½vÃ¡ ve funkci
                        <code>pyglet.app.run()</code>.
                        NaÄtenÃ­ vstupu (napÅ™. z klÃ¡vesnice) dÄ›lÃ¡ Pyglet sÃ¡m,
                        ale jejich zpracovÃ¡nÃ­ a vykreslenÃ­ vÃ½sledkÅ¯
                        uÅ¾ je pro kaÅ¾dÃ½ program jinÃ©, takÅ¾e si je budeme muset
                        naprogramovat samy.
                    </div>
                    <div>
                        ZatÃ­m pro nÃ¡s Pyglet zpracovÃ¡vÃ¡ jen dvÄ› udÃ¡losti:
                        zavÅ™enÃ­ okna (tlaÄÃ­tkem â€Ã—â€, kterÃ© k okÃ½nkÅ¯m pÅ™idÃ¡vÃ¡
                        operaÄnÃ­ systÃ©m), a stisk klÃ¡vesy <code>Esc</code>,
                        kterÃ½ taky zavÅ™e okno.
                        Po zavÅ™enÃ­ okna skonÄÃ­ smyÄka udÃ¡lostÃ­
                        (funkce <code>pyglet.app.run()</code>)
                        a program mÅ¯Å¾e pokraÄovat.
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Text</h2>
                    <div>
                        KlÃ¡vesa <code>esc</code> nenÃ­ pÅ™Ã­liÅ¡ zajÃ­mavÃ¡.
                        Zkusme reagovat i na jinÃ© klÃ¡vesy.
                    </div>
                    <div>
                        V Pygletu se na udÃ¡losti reaguje tak, Å¾e napÃ­Å¡eÅ¡
                        funkci, a pak ji <em>zaregistrujeÅ¡</em> (angl. register) â€“ Å™ekneÅ¡
                        Pygletu, aby ji vÅ¾dy v pravÃ½ Äas zavolal.
                        UdÃ¡losti, kterÃ¡ nastane kdyÅ¾ uÅ¾ivatel pÃ­Å¡e na klÃ¡vesnici,
                        se v Pygletu Å™Ã­kÃ¡ <code>on_text</code>,
                        a zpracovÃ¡vÃ¡ se takto:
                    </div>
<pre><span style="color:gray">
import pyglet
window = pyglet.window.Window()</span>

def zpracuj_text(text):
    print(text)

window.push_handlers(on_text=zpracuj_text)<span style="color:gray">

pyglet.app.run()</span>
</pre>
                    <div>
                        Co to dÄ›lÃ¡? <code>window.push_handlers(on_text=zpracuj_text)</code>
                        Å™ekne Pygletu, Å¾e kdyÅ¾ uÅ¾ivatel nÄ›co napÃ­Å¡e do naÅ¡eho okna,
                        mÃ¡ Pyglet zavolat funkci <code>zpracuj_text</code>.
                        Tahle funkce pak dostane jako argument text, kterÃ½ uÅ¾ivatel napsal.
                    </div>
                    <div class="note">
                        <div>
                            VÅ¡imni si, Å¾e pÅ™i registraci nepÃ­Å¡eme
                            <code>zpracuj_text()</code> se zÃ¡vorkami.
                        </div>
                        <div>
                            Asi uÅ¾ vÃ­Å¡, Å¾e
                            je rozdÃ­l mezi <code>print(int(8.2))</code>,
                            coÅ¾ funkci <code>int</code> zavolÃ¡
                            a <code>print</code> pak mÃ¡ k dispozici vÃ½sledek,
                            a <code>print(int)</code>,
                            coÅ¾ vypÃ­Å¡e samotnou funkci <code>int</code>.
                        </div>
                        <div>
                            Tady je to podobnÃ©:
                            Pyglet potÅ™ebuje samotnou funkci <code>zpracuj_text</code>
                            (protoÅ¾e ji bude sÃ¡m volat),
                            nikoli vÃ½sledek, kterÃ½ by vrÃ¡tila (v tomhle pÅ™Ã­padÄ› <code>None</code>,
                            protoÅ¾e <code>zpracuj_text</code> nic nevracÃ­).
                        </div>
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>ÄŒas â²</h2>
                    <div>
                        JeÅ¡tÄ› jednu udÃ¡lost zpracujme,
                        neÅ¾ se pÅ™esuneme ke grafice.
                    </div>
                    <div>
                        Bude to takzvanÃ½ <em>tik</em> hodin (angl. clock tick).
                        To je udÃ¡lost, kterÃ¡ nastÃ¡vÃ¡ pravidelnÄ› po nÄ›jakÃ©m Äase.
                    </div>
                    <div>
                        Funkce pro tiky se registruje takto:
                    </div>
<pre><span style="color:gray">
import pyglet
window = pyglet.window.Window()</span>

def tik(t):
    print(t)

pyglet.clock.schedule_interval(tik, 1/30)<span style="color:gray">

def zpracuj_text(text):
    print(text)

window.push_handlers(on_text=zpracuj_text)

pyglet.app.run()</span>
</pre>
                    <div>
                        Co to dÄ›lÃ¡? <code>pyglet.clock.schedule_interval(tik, 30)</code>
                        Å™ekne Pygletu, Å¾e mÃ¡ zavolat funkci <code>tik</code> kaÅ¾dou
                        tÅ™icetinu (<code>1/30</code>) vteÅ™iny.
                    </div>
                    <div>
                        A funkce <code>tik</code> dostane jeden argument â€“ kolik Äasu
                        uplynulo od poslednÃ­ho zavolÃ¡nÃ­.
                        VÄ›tÅ¡inou nenÃ­ pÅ™esnÄ› 1/30 vteÅ™iny, ale nÄ›co vÃ­c.
                        PoÄÃ­taÄ mÃ¡ i jinÃ© vÄ›ci na prÃ¡ci, takÅ¾e se k naÅ¡Ã­ aplikaci
                        nemusÃ­ dostat hned; a taky Pythonu trvÃ¡ nÄ›jakou tu
                        tisÃ­cinu vteÅ™iny neÅ¾ zpracuje zavolÃ¡nÃ­ naÅ¡Ã­ funkce.
                    </div>
                    <div class="note">
                        <div>
                            A proÄ vlastnÄ› tÅ™icetina vteÅ™iny?
                            Je to kvÅ¯li tomu, Å¾e potom budeme stavÄ›t animace.
                            KdyÅ¾ se nÃ¡m pÅ™ed oÄima vystÅ™Ã­dÃ¡ 30 obrÃ¡zkÅ¯ za vteÅ™inu,
                            mozek si je spojÃ­ a vznikne iluze plynulÃ©ho pohybu.
                            <br>
                            (VÄ›tÅ¡ina filmÅ¯ pouÅ¾Ã­vÃ¡ jen 24 obrÃ¡zkÅ¯ za vteÅ™inu.)
                        </div>
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>VykreslovÃ¡nÃ­</h2>
                    <img src="had.png" style="display:block;float:right;">
                    <div>
                        Program kterÃ½ vypisuje na terminÃ¡l spoustu ÄÃ­sel,
                        nenÃ­ asi zas tak zajÃ­mavÃ½.
                        TÃ©ma tÃ©hle strÃ¡nky je ale grafika, tak se zaÄnÄ›me od
                        terminÃ¡lu odpoutÃ¡vat. PojÄme kreslit.
                    </div>
                    <div>
                        Najdi si na internetu nÄ›jakÃ½ obrÃ¡zek. Ne moc velkÃ½,
                        tak 3cm, aÅ¥ je kolem nÄ›j v ÄernÃ©m okÃ½nku dost mÃ­sta,
                        a nejlÃ©pe ve formÃ¡tu PNG. ZaÄni tÅ™eba na
                        <a href="https://www.google.cz/search?tbs=ift:png&amp;tbm=isch&amp;q=snake+icon">tÃ©hle strÃ¡nce</a>.
                        UloÅ¾ si ho do adresÃ¡Å™e, odkud spouÅ¡tÃ­Å¡ svÅ¯j PythonÃ­
                        program. JÃ¡ mÃ¡m tÅ™eba obrÃ¡zek hada v souboru <code>had.png</code>.
                    </div>
                    <div>
                        Pak obrÃ¡zek vykresli (pouÅ¾ij jmÃ©no souboru se svÃ½m obrÃ¡zkem):
                    </div>
<pre><span style="color:gray">
import pyglet
window = pyglet.window.Window()

def tik(t):
    print(t)

pyglet.clock.schedule_interval(tik, 1/30)

def zpracuj_text(text):
    print(text)</span>

obrazek = pyglet.image.load(<span style="color:red">'had.png'</span>)
had = pyglet.sprite.Sprite(obrazek)

def vykresli():
    window.clear()
    had.draw()<span style="color:gray">

window.push_handlers(
    on_text=zpracuj_text,</span>
    on_draw=vykresli,<span style="color:gray">
)

pyglet.app.run()</span>
</pre>
                    <div>
                        Povedlo se?
                    </div>
                    <div>
                        VysvÄ›tleme si, co se tady dÄ›je:
                        <ul>
                            <li>
                                <code>obrazek = pyglet.image.load('had.png')</code>
                                naÄte ze souboru obrÃ¡zek
                            </li>
                            <li>
                                <code>had = pyglet.sprite.Sprite(obrazek)</code>
                                vytvoÅ™Ã­ speciÃ¡lnÃ­ objekt <a href="https://cs.wikipedia.org/wiki/Sprite_%28po%C4%8D%C3%ADta%C4%8Dov%C3%A1_grafika%29">Sprite</a>,
                                kterÃ½ urÄuje, Å¾e tento obrÃ¡zek chceme â€posaditâ€
                                na urÄitÃ© mÃ­sto v ÄernÃ©m okÃ½nku.
                                KdyÅ¾ neudÄ›lÃ¡me nic dalÅ¡Ã­ho, bude obrÃ¡zek Äekat v levÃ©m rohu.
                            </li>
                            <li>
                                Funkce <code>vykresli()</code>
                                se starÃ¡ vykreslenÃ­ okna â€“ vÃ½stup naÅ¡eho programu.
                                VolÃ¡ se vÅ¾dycky, kdyÅ¾ je potÅ™eba okno pÅ™ekreslit â€“
                                napÅ™Ã­klad kdyÅ¾ okno minimalizujeÅ¡ a pak vrÃ¡tÃ­Å¡,
                                nebo pÅ™esuneÅ¡ ÄÃ¡steÄnÄ› ven z obrazovky,
                                a pak dÃ¡Å¡ zase zpÄ›t.
                                A nebo kdyÅ¾ budeme nÄ›co animovat.
                                <div class="note">
                                    NÄ›kterÃ© operaÄnÃ­ systÃ©my si pamatujÃ­ i obsah oken,
                                    kterÃ© nejsou vidÄ›t, ale nenÃ­ radno na to spolÃ©hat.
                                </div>
                            </li>
                            <li>
                                <code>window.clear()</code>
                                vyÄistÃ­ okno â€“ natÅ™e ho Äernou barvou, a smaÅ¾e
                                vÅ¡echno, co v nÄ›m bylo pÅ™edtÃ­m.
                                <div class="note">
                                    Na spoustÄ› poÄÃ­taÄÅ¯ tohle nenÃ­ potÅ™eba.
                                    Ale je lepÅ¡Ã­ psÃ¡t programy tak, aby
                                    bÄ›Å¾ely kdekoli.
                                </div>
                            </li>
                            <li>
                                <code>had.draw()</code>
                                nakreslÃ­ obrÃ¡zek pomocÃ­ pÅ™edpÅ™ipravenÃ©ho objektu
                                <code>had</code>.
                            </li>
                            <li>
                                <code>window.push_handlers(on_draw=vykresli)</code>
                                zaregistruje funkci <code>vykresli</code> â€“ Å™ekne
                                Pygletu, aby ji volal vÅ¾dy kdyÅ¾ je tÅ™eba.
                                <br>
                                KdyÅ¾ potÅ™ebujeme zaregistrovat funkcÃ­ na obsluhu
                                udÃ¡lostÃ­ vÃ­c,
                                dajÃ­ se dÃ¡t funkci <code>push_handlers</code>
                                takhle najednou.
                            </li>
                        </ul>
                    </div>
                    <div>
                        JakÃ©koli kreslenÃ­ se <em>musÃ­</em> dÄ›lat v rÃ¡mci kreslÃ­cÃ­ funkce,
                        kterou Pyglet volÃ¡ z <code>on_draw</code>.
                        Jinde funkce jako <code>clear</code> a <code>draw</code>
                        nebudou fungovat.
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Animace</h2>
                    <div>
                        PojÄme si teÄ s naÅ¡Ã­m Spritem trochu pohrÃ¡t.
                    </div>
                    <div>
                        Do funkce <code>zpracuj_text</code> dej mÃ­sto printu tento pÅ™Ã­kaz:
                    </div>
<pre><span style="color:gray">
def zpracuj_text(text):</span>
    had.x = 150
</pre>
                    <div>
                        NÃ¡Å¡ Sprite mÃ¡ <em>atribut</em> (angl. attribute)
                        <code>x</code>, kterÃ½ urÄuje jeho <i>x</i>-ovou souÅ™adnici â€“
                        jak moc je vpravo od okraje okna.
                        Tenhle atribut se dÃ¡ nastavit, jak budeÅ¡ chtÃ­t â€“ nejÄastÄ›ji
                        v reakci na nÄ›jakou udÃ¡lost, ale Äasto se nastavuje
                        i na zaÄÃ¡tku programu.
                    </div>
                    <div>
                        ZajÃ­mavÃ© je zkusit k <code>x</code> nÄ›co pÅ™iÄÃ­st
                        pÅ™i kaÅ¾dÃ©m tiknutÃ­ hodin.
                        DokÃ¡Å¾eÅ¡ pÅ™edpovÄ›dÄ›t, co udÄ›lÃ¡ tenhle kÃ³d?
                    </div>
<pre>
def tik(t):
    had.x = had.x + t * 20
</pre>
                    <div>
                        NebojÃ­Å¡-li se matematiky, naimportuj <code>math</code>
                        a nech obrÃ¡zek, aÅ¥ se pohybuje podle nÄ›jakÃ© funkce:
                    </div>
<pre>
def tik(t):
    had.x = had.x + t * 20
    had.y = 20 + 20 * math.sin(had.x / 5)
</pre>
                    <div>
                        Co se stane, kdyÅ¾ zaÄneÅ¡ mÄ›nit ta ÄÃ­sla?
                    </div>
                    <div>
                        Co se stane, kdyÅ¾ zkusÃ­Å¡ podobnÄ› nastavovat atribut
                        <code>rotation</code>?
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>Zavolej pozdÄ›ji</h2>
                    <img src="had2.png" style="display:block;float:right;">
                    <div>
                        Pyglet umÃ­ kromÄ› opakovanÃ©ho â€tikÃ¡nÃ­â€ zavolat funkci
                        jednorÃ¡zovÄ›, za urÄitou dobu.
                    </div>
                    <div>
                        StÃ¡hni si (nebo vytvoÅ™) druhÃ½ obrÃ¡zek. (JÃ¡ mÃ¡m druhÃ©ho
                        hada, tentokrÃ¡t s trochu natoÄenou hlavou a ocasem.)
                    </div>
                    <div>
                        AÅ¾ budeÅ¡ mÃ­t obrÃ¡zek v  adresÃ¡Å™i s programem,
                        pÅ™idej tÄ›snÄ› pÅ™ed <code>pyglet.app.run()</code>
                        tenhle kus kÃ³du:
                    </div>
<pre>
obrazek2 = pyglet.image.load(<span style="color:red">'had2.png'</span>)

def zmen(t):
    had.image = obrazek2

pyglet.clock.schedule_once(zmen, 1)

</pre>
                    <div>
                        VolÃ¡nÃ­ <code>schedule_once(zmen, 1)</code> Å™Ã­kÃ¡ Pygletu,
                        Å¾e za jednu vteÅ™inu mÃ¡ zavolat funkci <code>zmen</code>.
                        A funkce zmÄ›nÃ­ obrÃ¡zek â€“ stejnÄ› jako se pÅ™edtÃ­m mÄ›nily
                        souÅ™adnice.
                    </div>
                    <hr>
                    <div>
                        <code>schedule_once</code> se dÃ¡ volat i v rÃ¡mci
                        obsluhy jinÃ© udÃ¡losti. Zkus funkci <code>zmen</code>
                        nahradit tÃ­mhle:
                    </div>
<pre>
def zmen(t):
    had.image = obrazek2
    pyglet.clock.schedule_once(zmen_zpatky, 0.2)

def zmen_zpatky(t):
    had.image = obrazek
    pyglet.clock.schedule_once(zmen, 0.2)
</pre>
                </section>
                <section class="col-lg-12">
                    <h2>Klik ğŸ­</h2>
                    <div>
                        PoslednÃ­ vÄ›c, na kterou se tady nauÄÃ­me reagovat,
                        je klikÃ¡nÃ­.
                        TÄ›snÄ› pÅ™ed <code>window.push_handlers</code>
                        napiÅ¡ funkci:
                    </div>
<pre>
def klik(x, y, tlacitko, mod):
    had.x = x
    had.y = y
</pre>
                    <div>
                        â€¦ a pak v <code>push_handlers</code> ji zaregistruj
                        pomocÃ­ Å™Ã¡dku <code>on_mouse_press=klik,</code>.
                    </div>
                    <div>
                        Co znamenÃ¡ kterÃ½ argument, to zkus zjistit sama.
                        <div class="note">
                            NÃ¡povÄ›da:
                            <ul>
                                <li>Dokud pÅ™Ã­kazovou Å™Ã¡dku neopustÃ­Å¡ ÃºplnÄ›, bude fungovat <code>print</code>!</li>
                                <li>Kolik mÃ¡ myÅ¡ tlaÄÃ­tek?</li>
                                <li>Jak se projevÃ­ Shift+klik?</li>
                        </div>
                    </div>
                </section>
                <section class="col-lg-12">
                    <h2>PokraÄovÃ¡nÃ­ pÅ™Ã­Å¡tÄ›</h2>
                    <div>
                        KoukÃ¡m Å¾e kÃ³du uÅ¾ je dnes tak akorÃ¡t na ukonÄenÃ­ lekce:
                    </div>
<pre>
import math

import pyglet

window = pyglet.window.Window()

def tik(t):
    had.x = had.x + t * 20

pyglet.clock.schedule_interval(tik, 1/30)

def zpracuj_text(text):
    had.x = 150
    had.rotation = had.rotation + 10

obrazek = pyglet.image.load('had.png')
had = pyglet.sprite.Sprite(obrazek, x=10, y=10)

def vykresli():
    window.clear()
    had.draw()

def klik(x, y, tlacitko, mod):
    print(tlacitko, mod)
    had.x = x
    had.y = y

window.push_handlers(
    on_text=zpracuj_text,
    on_draw=vykresli,
    on_mouse_press=klik,
)

obrazek2 = pyglet.image.load('had2.png')

def zmen(t):
    had.image = obrazek2
    pyglet.clock.schedule_once(zmen_zpatky, 0.2)

def zmen_zpatky(t):
    had.image = obrazek
    pyglet.clock.schedule_once(zmen, 0.2)

pyglet.clock.schedule_once(zmen, 0.2)

pyglet.app.run()
</pre>
                    <div>
                        Se vstupem z klÃ¡vesnice a myÅ¡i, ÄasovÃ¡nÃ­m, a vykreslovÃ¡nÃ­m
                        Spritu si vystaÄÃ­Å¡ u leckterÃ© hry nebo grafickÃ© aplikace.
                    </div>
                    <div>
                        AÅ¾ budeÅ¡ nÄ›jakou dÄ›lat, zkus mÃ­t:
                        stav aplikace mÄ›j v seznamech a n-ticÃ­ch (pÅ™Ã­padnÄ›
                        slovnÃ­cÃ­ch a tÅ™Ã­dÃ¡ch, kterÃ© se nauÄÃ­me pozdÄ›ji).
                        Jedna funkce by mÄ›la umÄ›t takovÃ½ stav vykreslit, a
                        jinÃ© s nÃ­m pak budou manipulovat.
                    </div>
                    <div>
                        ZajÃ­mÃ¡-li tÄ› toto tÃ©ma, zkus si zahrÃ¡t pÅ™iloÅ¾enou hru
                        <a href="pong.py">Pong</a>, kterÃ¡ ukazuje nÄ›kterÃ© dalÅ¡Ã­
                        moÅ¾nosti Pygletu: psanÃ­ textu, kreslenÃ­ obdÃ©lnÃ­kÅ¯,
                        a obsluhu jednotlivÃ½ch klÃ¡ves (napÅ™. Å¡ipek).
                        Na prvnÃ­ pohled mÅ¯Å¾e jejÃ­ kÃ³d vypadat sloÅ¾itÄ›,
                        ale zkus si k nÄ›mu sednout, a s pomocÃ­ komentÃ¡Å™Å¯
                        ho pochopit.
                        Kdyby komentÃ¡Å™e nestaÄily, jsou k Pongu pÅ™ipravenÃ©
                        i <a href="pong.html">podrobnÃ© materiÃ¡ly</a>.
                    </div>
                    <div>
                        A chceÅ¡-li se do Pygletu ponoÅ™it hloubÄ›ji,
                        existuje pro nÄ›j <a href="http://pyglet.readthedocs.org/en/latest/index.html">dokumentace</a>.
                        Nebude-li ti v nÃ­ nÄ›co jasnÃ©, zeptej se!
                    </div>
                </section>
            </div>
            <div class="no-reveal footer">
                <div>pro PyLadies Brno napsal Petr Viktorin, 2015</div>
                <div>Licence: <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a></div>
            </div>
        </div>

        <script src="../reveal.js/lib/js/head.min.js"></script>
        <script type="text/javascript" src="../js/solutions.js"></script>

    </body>
</html>
